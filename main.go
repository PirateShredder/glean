package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"
)

const (
	maxFileSize      = 100 * 1024 // 100KB
	maxTotalBlobSize = 100 * 1024 // 100KB
	todoHeader       = "<!-- AUTO-GENERATED BY TODO-SCANNER -->\n\n"
)

var debugMode bool
var userContext string

// ActionItem represents a single structured action item from the AI
type ActionItem struct {
	Item     string `json:"item"`
	Priority string `json:"priority"`
	Type     string `json:"type"`
}

// FileActionItems is a helper struct to associate action items with their source file
type FileActionItems struct {
	FilePath    string
	ActionItems []ActionItem
}

func debugPrint(format string, args ...interface{}) {
	if debugMode {
		fmt.Printf("[DEBUG] "+format+"\n", args...)
	}
}

func printHeader() {
	header := `
╔═══════════════════════════════════════════════════════════════╗
║                                                               
║                     TODO SCANNER v1.0                         ║
║                                                               
║         Intelligent AI-Powered Action Item Extractor         ║
║                                                               
╚═══════════════════════════════════════════════════════════════╝
`
	fmt.Println(header)
}

func printUsage() {
	printHeader()
	fmt.Println("USAGE:")
	fmt.Println("  todo-scanner -scan [options]    Scan directory and generate TODO.md")
	fmt.Println("  todo-scanner -gather [options]  Consolidate all TODOs into MASTER_TODO.md")
	fmt.Println()
	fmt.Println("OPTIONS:")
	fmt.Println("  -scan          Scan current directory for .md/.txt files and extract action items")
	fmt.Println("  -gather        Gather all auto-generated TODO.md files and consolidate them")
	fmt.Println("  -ctx <text>    Provide context for AI analysis (inline)")
	fmt.Println("  -fctx <file>   Provide context for AI analysis from a file")
	fmt.Println("  --debug        Enable verbose debug output")
	fmt.Println("  --max-concurrent <int>  Maximum concurrent Gemini sessions (default: 5)")
	fmt.Println()
	fmt.Println("EXAMPLES:")
	fmt.Println("  ./todo-scanner -scan")
	fmt.Println("  ./todo-scanner -scan -ctx \"Infrastructure project for renewable energy\"")
	fmt.Println("  ./todo-scanner -scan -fctx ./project-context.txt")
	fmt.Println("  ./todo-scanner -scan --debug")
	fmt.Println("  ./todo-scanner -scan --max-concurrent 10")
	fmt.Println("  ./todo-scanner -gather --debug")
	fmt.Println()
}

// Spinner shows a loading animation
type Spinner struct {
	message string
	active  bool
	done    chan bool
}

func NewSpinner(message string) *Spinner {
	return &Spinner{
		message: message,
		active:  false,
		done:    make(chan bool),
	}
}

func (s *Spinner) Start() {
	if debugMode {
		return
	}
	s.active = true
	go func() {
		chars := []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}
		i := 0
		for s.active {
			select {
			case <-s.done:
				fmt.Print("\r\033[K")
				return
			case <-time.After(100 * time.Millisecond):
				fmt.Printf("\r%s %s", chars[i], s.message)
				i = (i + 1) % len(chars)
			}
		}
	}()
}

func (s *Spinner) Stop() {
	if debugMode {
		return
	}
	if s.active {
		s.active = false
		s.done <- true
		fmt.Print("\r\033[K")
	}
}

func main() {
	scanMode := flag.Bool("scan", false, "Scan directory for .md and .txt files and generate TODO.md")
	gatherMode := flag.Bool("gather", false, "Gather all TODO.md files and create MASTER_TODO.md")
	debug := flag.Bool("debug", false, "Enable debug output")
	ctx := flag.String("ctx", "", "Provide context for AI analysis (inline)")
	fctx := flag.String("fctx", "", "Provide context for AI analysis from a file")
	maxConcurrent := flag.Int("max-concurrent", 5, "Maximum concurrent Gemini sessions")
	flag.Parse()

	debugMode = *debug

	if *scanMode && *gatherMode {
		fmt.Println("Error: Cannot use both -scan and -gather modes simultaneously")
		printUsage()
		os.Exit(1)
	}

	if !*scanMode && !*gatherMode {
		printUsage()
		os.Exit(1)
	}

	if *ctx != "" && *fctx != "" {
		fmt.Println("Error: Cannot use both -ctx and -fctx simultaneously")
		printUsage()
		os.Exit(1)
	}

	if *ctx != "" {
		userContext = *ctx
	} else if *fctx != "" {
		contextBytes, err := os.ReadFile(*fctx)
		if err != nil {
			fmt.Printf("Error reading context file %s: %v\n", *fctx, err)
			os.Exit(1)
		}
		userContext = string(contextBytes)
	}

	cwd, err := os.Getwd()
	if err != nil {
		fmt.Printf("Error getting current directory: %v\n", err)
		os.Exit(1)
	}

	if *scanMode {
		if err := runScanMode(cwd, *maxConcurrent); err != nil {
			fmt.Printf("Error in scan mode: %v\n", err)
			os.Exit(1)
		}
	} else if *gatherMode {
		if err := runGatherMode(cwd); err != nil {
			fmt.Printf("Error in gather mode: %v\n", err)
			os.Exit(1)
		}
	}
}

// runScanMode scans for .md and .txt files, processes them in parallel with Gemini
func runScanMode(rootDir string, maxConcurrent int) error {
	debugPrint("Starting scan mode in directory: %s", rootDir)
	fmt.Println("Scanning directory for .md and .txt files...")

	files, err := findReadableFiles(rootDir)
	if err != nil {
		return fmt.Errorf("error finding files: %w", err)
	}

	if len(files) == 0 {
		fmt.Println("No .md or .txt files found")
		return nil
	}

	fmt.Printf("Found %d files. Processing with Gemini in parallel...\n", len(files))

	fileActionItems, err := processFilesInParallel(files, rootDir, maxConcurrent)
	if err != nil {
		return fmt.Errorf("error processing files: %w", err)
	}

	combined := formatTodosAsMarkdown(fileActionItems)

	todoPath := filepath.Join(rootDir, "TODO.md")
	if err := writeTodoFile(todoPath, combined); err != nil {
		return fmt.Errorf("error writing TODO.md: %w", err)
	}

	fmt.Printf("✓ TODO.md created at: %s\n", todoPath)
	return nil
}

// formatTodosAsMarkdown converts structured action items into a markdown string
func formatTodosAsMarkdown(fileItems []FileActionItems) string {
	if len(fileItems) == 0 {
		return "No action items found in the scanned files."
	}

	var builder strings.Builder
	totalItems := 0
	for _, fileItem := range fileItems {
		if len(fileItem.ActionItems) > 0 {
			builder.WriteString(fmt.Sprintf("\n### From: %s\n", fileItem.FilePath))
			for _, item := range fileItem.ActionItems {
				sanitizedItem := strings.ReplaceAll(item.Item, "\n", " ")
				builder.WriteString(fmt.Sprintf("- **[%s]** %s\n", item.Priority, sanitizedItem))
			}
			totalItems += len(fileItem.ActionItems)
		}
	}

	if totalItems == 0 {
		return "No action items found in the scanned files."
	}

	return builder.String()
}

// processFilesInParallel processes each file with Gemini concurrently
func processFilesInParallel(files []string, rootDir string, maxConcurrent int) ([]FileActionItems, error) {
	debugPrint("Processing %d files in parallel (max %d concurrent)", len(files), maxConcurrent)

	var wg sync.WaitGroup
	sem := make(chan struct{}, maxConcurrent)
	resultsChan := make(chan FileActionItems, len(files))
	errorsChan := make(chan error, len(files))

	for i, file := range files {
		wg.Add(1)
		go func(idx int, filePath string) {
			defer wg.Done()
			sem <- struct{}{}
			defer func() { <-sem }()

			relPath, _ := filepath.Rel(rootDir, filePath)
			debugPrint("[%d/%d] Processing file: %s", idx+1, len(files), relPath)

			content, err := os.ReadFile(filePath)
			if err != nil {
				errorsChan <- fmt.Errorf("error reading %s: %w", filePath, err)
				return
			}

			cleaned := cleanContent(string(content))
			if len(cleaned) < 10 {
				return
			}

			actionItems, err := callGeminiForFile(cleaned, relPath)
			if err != nil {
				errorsChan <- fmt.Errorf("error processing %s with Gemini: %w", filePath, err)
				return
			}

			if len(actionItems) > 0 {
				debugPrint("[%d/%d] Received %d action items from %s", idx+1, len(files), len(actionItems), relPath)
				resultsChan <- FileActionItems{FilePath: relPath, ActionItems: actionItems}
			} else {
				debugPrint("[%d/%d] No action items found in %s", idx+1, len(files), relPath)
			}
		}(i, file)
	}

	wg.Wait()
	close(resultsChan)
	close(errorsChan)

	var errors []error
	for err := range errorsChan {
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		for _, err := range errors {
			fmt.Printf("Warning: %v\n", err)
		}
	}

	var results []FileActionItems
	for result := range resultsChan {
		results = append(results, result)
	}

	sort.Slice(results, func(i, j int) bool {
		return results[i].FilePath < results[j].FilePath
	})

	debugPrint("Collected %d file results from parallel processing", len(results))
	return results, nil
}

// runGatherMode finds all auto-generated TODO.md files and creates MASTER_TODO.md
func runGatherMode(rootDir string) error {
	debugPrint("Starting gather mode in directory: %s", rootDir)
	fmt.Println("Gathering all TODO.md files...")

	todoFiles, err := findAutoGeneratedTodos(rootDir)
	if err != nil {
		return fmt.Errorf("error finding TODO files: %w", err)
	}

	if len(todoFiles) == 0 {
		fmt.Println("No auto-generated TODO.md files found")
		return nil
	}

	fmt.Printf("Found %d TODO.md files. Consolidating...\n", len(todoFiles))

	consolidated, err := consolidateTodos(todoFiles)
	if err != nil {
		return fmt.Errorf("error consolidating TODOs: %w", err)
	}

	fmt.Printf("Consolidated content size: %d bytes. Sending to Gemini...\n", len(consolidated))

	summary, err := callGeminiForSummary(consolidated)
	if err != nil {
		return fmt.Errorf("error calling Gemini: %w", err)
	}

	masterPath := filepath.Join(rootDir, "MASTER_TODO.md")
	if err := writeMasterTodoFile(masterPath, summary); err != nil {
		return fmt.Errorf("error writing MASTER_TODO.md: %w", err)
	}

	fmt.Printf("✓ MASTER_TODO.md created at: %s\n", masterPath)
	return nil
}

// findReadableFiles recursively finds .md and .txt files, excluding hidden dirs and large files
func findReadableFiles(root string) ([]string, error) {
	var files []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() && strings.HasPrefix(info.Name(), ".") && path != root {
			return filepath.SkipDir
		}
		if !info.Mode().IsRegular() {
			return nil
		}
		if info.Size() > maxFileSize {
			return nil
		}
		ext := strings.ToLower(filepath.Ext(path))
		if ext == ".md" || ext == ".txt" {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

// cleanContent removes excessive whitespace and blank lines
func cleanContent(content string) string {
	var cleaned strings.Builder
	scanner := bufio.NewScanner(strings.NewReader(content))
	prevBlank := false
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			if !prevBlank {
				cleaned.WriteString("\n")
				prevBlank = true
			}
			continue
		}
		cleaned.WriteString(line)
		cleaned.WriteString("\n")
		prevBlank = false
	}
	return cleaned.String()
}

// callGeminiForFile calls Gemini CLI to extract action items in a structured JSON format
func callGeminiForFile(content string, filename string) ([]ActionItem, error) {
	startTime := time.Now()
	debugPrint("Calling Gemini for file: %s", filename)

	contextSection := ""
	if userContext != "" {
		contextSection = fmt.Sprintf("Project Context: %s\n\n", userContext)
	}

	prompt := fmt.Sprintf(`You are an AI assistant analyzing a file to extract action items.
%s
Review the following document content and extract ALL action items, TODOs, pending tasks, and items requiring follow-up.

Return ONLY a valid JSON array of objects. Each object must have these exact keys: "item" (string), "priority" (string: "High", "Medium", or "Low"), and "type" (string: "explicit" for keywords like TODO/FIXME, or "implicit" for inferred tasks).

If no action items are found, return an empty JSON array: [].

File: %s

Content:
%s`, contextSection, filename, content)

	debugPrint("PROMPT for %s:\n%s", filename, prompt)

	spinner := NewSpinner(fmt.Sprintf("Processing %s with Gemini AI...", filename))
	spinner.Start()
	defer spinner.Stop()

	cmd := exec.Command("gemini")
	cmd.Stdin = strings.NewReader(prompt)

	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("gemini command failed for %s: %w\nStderr: %s", filename, err, stderr.String())
	}

	elapsed := time.Since(startTime)
	debugPrint("Gemini for %s completed in %v", filename, elapsed)

	result := strings.TrimSpace(out.String())
	debugPrint("Raw Gemini output for %s: %s", filename, result)

	// Clean the result to extract JSON from markdown code blocks
	cleanedResult := strings.TrimPrefix(result, "```json")
	cleanedResult = strings.TrimSuffix(cleanedResult, "```")
	cleanedResult = strings.TrimSpace(cleanedResult)

	var actionItems []ActionItem
	if err := json.Unmarshal([]byte(cleanedResult), &actionItems); err != nil {
		debugPrint("Failed to unmarshal JSON from Gemini for %s: %v. Treating as plain text.", filename, err)
		if cleanedResult != "" && cleanedResult != "[]" {
			return []ActionItem{{Item: result, Priority: "Medium", Type: "unknown"}}, nil
		}
		return []ActionItem{}, nil
	}

	debugPrint("Successfully unmarshalled %d action items from %s", len(actionItems), filename)
	return actionItems, nil
}

// callGeminiForSummary calls Gemini CLI to summarize, deduplicate, and categorize items
func callGeminiForSummary(consolidated string) (string, error) {
	startTime := time.Now()
	debugPrint("Calling Gemini for summary consolidation")

	contextSection := ""
	if userContext != "" {
		contextSection = fmt.Sprintf("Here is the overall project context: %s\n\n", userContext)
	}

	prompt := fmt.Sprintf(`You are an expert project manager AI. Your task is to consolidate a list of action items extracted from multiple files into a single, clean, and organized master TODO list.

%sReview all the action items provided below. Your goal is to:
1.  **Deduplicate:** Merge identical or very similar action items into a single entry.
2.  **Organize:** Group the unique action items into thematic categories (e.g., "API & Backend", "Documentation", "Testing", "Refactoring").
3.  **Prioritize:** Within each category, try to list the most important items first.
4.  **Format:** Return a single, clean markdown document. Do NOT include the original file paths in the final output.

The output should be a well-structured markdown list, ready for a MASTER_TODO.md file.

All TODO items:
%s`, contextSection, consolidated)

	debugPrint("PROMPT for summary:\n%s", prompt)

	spinner := NewSpinner("Consolidating and organizing with Gemini AI...")
	spinner.Start()
	defer spinner.Stop()

	cmd := exec.Command("gemini")
	cmd.Stdin = strings.NewReader(prompt)

	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("gemini summary command failed: %w\nStderr: %s", err, stderr.String())
	}

	elapsed := time.Since(startTime)
	debugPrint("Gemini summary completed in %v", elapsed)

	result := strings.TrimSpace(out.String())
	debugPrint("Gemini summary output length: %d bytes", len(result))

	return result, nil
}

// findAutoGeneratedTodos finds all TODO.md files created by this tool
func findAutoGeneratedTodos(root string) ([]string, error) {
	var todoFiles []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() && strings.HasPrefix(info.Name(), ".") && path != root {
			return filepath.SkipDir
		}
		if !info.IsDir() && info.Name() == "TODO.md" {
			content, err := os.ReadFile(path)
			if err != nil {
				return nil
			}
			if strings.HasPrefix(string(content), todoHeader) {
				todoFiles = append(todoFiles, path)
			}
		}
		return nil
	})
	return todoFiles, err
}

// consolidateTodos reads all TODO files and concatenates them
func consolidateTodos(todoFiles []string) (string, error) {
	var consolidated strings.Builder
	for _, file := range todoFiles {
		content, err := os.ReadFile(file)
		if err != nil {
			fmt.Printf("Warning: Could not read %s: %v\n", file, err)
			continue
		}
		contentStr := strings.TrimPrefix(string(content), todoHeader)
		consolidated.WriteString(fmt.Sprintf("=== From: %s ===\n", file))
		consolidated.WriteString(contentStr)
		consolidated.WriteString("\n\n")
	}
	return consolidated.String(), nil
}

// writeTodoFile writes the TODO.md file with header
func writeTodoFile(path string, content string) error {
	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	if _, err := file.WriteString(todoHeader); err != nil {
		return err
	}
	if _, err := file.WriteString(content); err != nil {
		return err
	}
	return nil
}

// writeMasterTodoFile writes the MASTER_TODO.md file
func writeMasterTodoFile(path string, content string) error {
	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	header := "# MASTER TODO - Consolidated Action Items\n\n"
	header += "<!-- AUTO-GENERATED BY TODO-SCANNER -->\n\n"

	if _, err := file.WriteString(header); err != nil {
		return err
	}
	if _, err := file.WriteString(content); err != nil {
		return err
	}
	return nil
}